#!/usr/bin/env python3.8
# @generated by pegen from c.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
from cast import Name

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: external_declaration* $
        mark = self._mark()
        if (
            (_loop0_1 := self._loop0_1(),)
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return [_loop0_1, _endmarker]
        self._reset(mark)
        return None

    @memoize
    def any(self) -> Optional[Any]:
        # any: any1+
        mark = self._mark()
        if (
            (_loop1_2 := self._loop1_2())
        ):
            return _loop1_2
        self._reset(mark)
        return None

    @memoize
    def any1(self) -> Optional[Any]:
        # any1: NAME | NUMBER | STRING | '(' ~ any* ')' | '{' ~ any* '}' | '[' ~ any* ']' | !(';' | ')' | '}' | ']') OP | ';'
        mark = self._mark()
        if (
            (n := self.name())
        ):
            return Name ( n . string )
        self._reset(mark)
        if (
            (n := self.number())
        ):
            return n . string
        self._reset(mark)
        if (
            (n := self.string())
        ):
            return n . string
        self._reset(mark)
        cut = False
        if (
            (literal := self.expect('('))
            and
            (cut := True)
            and
            (a := self._loop0_3(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (cut := True)
            and
            (a := self._loop0_4(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return a
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (cut := True)
            and
            (a := self._loop0_5(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return a
        self._reset(mark)
        if cut: return None
        if (
            self.negative_lookahead(self._tmp_6, )
            and
            (op := self.op())
        ):
            return op
        self._reset(mark)
        if (
            (literal := self.expect(';'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def identifier(self) -> Optional[Any]:
        # identifier: NAME
        mark = self._mark()
        if (
            (n := self.name())
        ):
            return Name ( n . string )
        self._reset(mark)
        return None

    @memoize
    def string_literal(self) -> Optional[Any]:
        # string_literal: STRING
        mark = self._mark()
        if (
            (string := self.string())
        ):
            return string
        self._reset(mark)
        return None

    @memoize
    def constant(self) -> Optional[Any]:
        # constant: NUMBER | STRING
        mark = self._mark()
        if (
            (number := self.number())
        ):
            return number
        self._reset(mark)
        if (
            (string := self.string())
        ):
            return string
        self._reset(mark)
        return None

    @memoize
    def enumeration_constant(self) -> Optional[Any]:
        # enumeration_constant: NAME
        mark = self._mark()
        if (
            (name := self.name())
        ):
            return name
        self._reset(mark)
        return None

    @memoize
    def external_declaration(self) -> Optional[Any]:
        # external_declaration: function_definition | declaration
        mark = self._mark()
        if (
            (function_definition := self.function_definition())
        ):
            return function_definition
        self._reset(mark)
        if (
            (declaration := self.declaration())
        ):
            return declaration
        self._reset(mark)
        return None

    @memoize
    def function_definition(self) -> Optional[Any]:
        # function_definition: declaration_specifier+ declarator declaration* compound_statement
        mark = self._mark()
        if (
            (_loop1_7 := self._loop1_7())
            and
            (declarator := self.declarator())
            and
            (_loop0_8 := self._loop0_8(),)
            and
            (compound_statement := self.compound_statement())
        ):
            return [_loop1_7, declarator, _loop0_8, compound_statement]
        self._reset(mark)
        return None

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement
        mark = self._mark()
        if (
            (labeled_statement := self.labeled_statement())
        ):
            return labeled_statement
        self._reset(mark)
        if (
            (compound_statement := self.compound_statement())
        ):
            return compound_statement
        self._reset(mark)
        if (
            (expression_statement := self.expression_statement())
        ):
            return expression_statement
        self._reset(mark)
        if (
            (selection_statement := self.selection_statement())
        ):
            return selection_statement
        self._reset(mark)
        if (
            (iteration_statement := self.iteration_statement())
        ):
            return iteration_statement
        self._reset(mark)
        if (
            (jump_statement := self.jump_statement())
        ):
            return jump_statement
        self._reset(mark)
        return None

    @memoize
    def labeled_statement(self) -> Optional[Any]:
        # labeled_statement: 'case' ~ constant_expression ':' statement | 'default' ~ ':' statement | identifier ':' statement
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('case'))
            and
            (cut := True)
            and
            (constant_expression := self.constant_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (statement := self.statement())
        ):
            return [literal, constant_expression, literal_1, statement]
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('default'))
            and
            (cut := True)
            and
            (literal_1 := self.expect(':'))
            and
            (statement := self.statement())
        ):
            return [literal, literal_1, statement]
        self._reset(mark)
        if cut: return None
        if (
            (identifier := self.identifier())
            and
            (literal := self.expect(':'))
            and
            (statement := self.statement())
        ):
            return [identifier, literal, statement]
        self._reset(mark)
        return None

    @memoize
    def compound_statement(self) -> Optional[Any]:
        # compound_statement: '{' block_item* '}'
        mark = self._mark()
        if (
            (literal := self.expect('{'))
            and
            (_loop0_9 := self._loop0_9(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, _loop0_9, literal_1]
        self._reset(mark)
        return None

    @memoize
    def block_item(self) -> Optional[Any]:
        # block_item: declaration | statement
        mark = self._mark()
        if (
            (declaration := self.declaration())
        ):
            return declaration
        self._reset(mark)
        if (
            (statement := self.statement())
        ):
            return statement
        self._reset(mark)
        return None

    @memoize
    def expression_statement(self) -> Optional[Any]:
        # expression_statement: expression? ';'
        mark = self._mark()
        if (
            (opt := self.expression(),)
            and
            (literal := self.expect(';'))
        ):
            return [opt, literal]
        self._reset(mark)
        return None

    @memoize
    def selection_statement(self) -> Optional[Any]:
        # selection_statement: 'if' '(' expression ')' statement 'else' statement | 'if' '(' expression ')' statement | 'switch' '(' expression ')' statement
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (literal_1 := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_2 := self.expect(')'))
            and
            (statement := self.statement())
            and
            (literal_3 := self.expect('else'))
            and
            (statement_1 := self.statement())
        ):
            return [literal, literal_1, expression, literal_2, statement, literal_3, statement_1]
        self._reset(mark)
        if (
            (literal := self.expect('if'))
            and
            (literal_1 := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_2 := self.expect(')'))
            and
            (statement := self.statement())
        ):
            return [literal, literal_1, expression, literal_2, statement]
        self._reset(mark)
        if (
            (literal := self.expect('switch'))
            and
            (literal_1 := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_2 := self.expect(')'))
            and
            (statement := self.statement())
        ):
            return [literal, literal_1, expression, literal_2, statement]
        self._reset(mark)
        return None

    @memoize
    def iteration_statement(self) -> Optional[Any]:
        # iteration_statement: 'while' ~ '(' expression ')' statement | 'do' ~ statement 'while' '(' expression ')' ';' | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('while'))
            and
            (cut := True)
            and
            (literal_1 := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_2 := self.expect(')'))
            and
            (statement := self.statement())
        ):
            return [literal, literal_1, expression, literal_2, statement]
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('do'))
            and
            (cut := True)
            and
            (statement := self.statement())
            and
            (literal_1 := self.expect('while'))
            and
            (literal_2 := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_3 := self.expect(')'))
            and
            (literal_4 := self.expect(';'))
        ):
            return [literal, statement, literal_1, literal_2, expression, literal_3, literal_4]
        self._reset(mark)
        if cut: return None
        if (
            (literal := self.expect('for'))
            and
            (literal_1 := self.expect('('))
            and
            (opt := self.expression(),)
            and
            (literal_2 := self.expect(';'))
            and
            (opt_1 := self.expression(),)
            and
            (literal_3 := self.expect(';'))
            and
            (opt_2 := self.expression(),)
            and
            (literal_4 := self.expect(')'))
            and
            (statement := self.statement())
        ):
            return [literal, literal_1, opt, literal_2, opt_1, literal_3, opt_2, literal_4, statement]
        self._reset(mark)
        if (
            (literal := self.expect('for'))
            and
            (literal_1 := self.expect('('))
            and
            (declaration := self.declaration())
            and
            (opt := self.expression(),)
            and
            (literal_2 := self.expect(';'))
            and
            (opt_1 := self.expression(),)
            and
            (literal_3 := self.expect(')'))
            and
            (statement := self.statement())
        ):
            return [literal, literal_1, declaration, opt, literal_2, opt_1, literal_3, statement]
        self._reset(mark)
        return None

    @memoize
    def jump_statement(self) -> Optional[Any]:
        # jump_statement: 'goto' ~ identifier ';' | 'continue' ~ ';' | 'break' ~ ';' | 'return' ~ expression? ';'
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('goto'))
            and
            (cut := True)
            and
            (identifier := self.identifier())
            and
            (literal_1 := self.expect(';'))
        ):
            return [literal, identifier, literal_1]
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('continue'))
            and
            (cut := True)
            and
            (literal_1 := self.expect(';'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('break'))
            and
            (cut := True)
            and
            (literal_1 := self.expect(';'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('return'))
            and
            (cut := True)
            and
            (opt := self.expression(),)
            and
            (literal_1 := self.expect(';'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        if cut: return None
        return None

    @memoize
    def declaration(self) -> Optional[Any]:
        # declaration: declaration_specifier+ ','.(init_declarator)+? ';' | static_assert_declaration
        mark = self._mark()
        if (
            (_loop1_10 := self._loop1_10())
            and
            (opt := self._gather_11(),)
            and
            (literal := self.expect(';'))
        ):
            return [_loop1_10, opt, literal]
        self._reset(mark)
        if (
            (static_assert_declaration := self.static_assert_declaration())
        ):
            return static_assert_declaration
        self._reset(mark)
        return None

    @memoize
    def init_declarator(self) -> Optional[Any]:
        # init_declarator: declarator '=' initializer | declarator
        mark = self._mark()
        if (
            (declarator := self.declarator())
            and
            (literal := self.expect('='))
            and
            (initializer := self.initializer())
        ):
            return [declarator, literal, initializer]
        self._reset(mark)
        if (
            (declarator := self.declarator())
        ):
            return declarator
        self._reset(mark)
        return None

    @memoize
    def declaration_specifier(self) -> Optional[Any]:
        # declaration_specifier: storage_class_specifier | type_specifier | type_qualifier | function_specifier | alignment_specifier
        mark = self._mark()
        if (
            (storage_class_specifier := self.storage_class_specifier())
        ):
            return storage_class_specifier
        self._reset(mark)
        if (
            (type_specifier := self.type_specifier())
        ):
            return type_specifier
        self._reset(mark)
        if (
            (type_qualifier := self.type_qualifier())
        ):
            return type_qualifier
        self._reset(mark)
        if (
            (function_specifier := self.function_specifier())
        ):
            return function_specifier
        self._reset(mark)
        if (
            (alignment_specifier := self.alignment_specifier())
        ):
            return alignment_specifier
        self._reset(mark)
        return None

    @memoize
    def storage_class_specifier(self) -> Optional[str]:
        # storage_class_specifier: ('typedef' | 'extern' | 'static') | ('_Thread_local' | 'auto' | 'register')
        mark = self._mark()
        if (
            (a := self._tmp_13())
        ):
            return a . string
        self._reset(mark)
        if (
            (a := self._tmp_14())
        ):
            return a . string
        self._reset(mark)
        return None

    @memoize
    def type_specifier(self) -> Optional[Any]:
        # type_specifier: 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | '_Bool' | '_Complex' | atomic_type_specifier | struct_or_union_specifier | enum_specifier | typedef_name | '__attribute__' '(' any ')'
        mark = self._mark()
        if (
            (literal := self.expect('void'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('char'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('short'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('int'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('long'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('float'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('double'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('signed'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('unsigned'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('_Bool'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('_Complex'))
        ):
            return literal
        self._reset(mark)
        if (
            (atomic_type_specifier := self.atomic_type_specifier())
        ):
            return atomic_type_specifier
        self._reset(mark)
        if (
            (struct_or_union_specifier := self.struct_or_union_specifier())
        ):
            return struct_or_union_specifier
        self._reset(mark)
        if (
            (enum_specifier := self.enum_specifier())
        ):
            return enum_specifier
        self._reset(mark)
        if (
            (typedef_name := self.typedef_name())
        ):
            return typedef_name
        self._reset(mark)
        if (
            (literal := self.expect('__attribute__'))
            and
            (literal_1 := self.expect('('))
            and
            (any := self.any())
            and
            (literal_2 := self.expect(')'))
        ):
            return [literal, literal_1, any, literal_2]
        self._reset(mark)
        return None

    @memoize
    def struct_or_union_specifier(self) -> Optional[Any]:
        # struct_or_union_specifier: ('struct' | 'union') identifier? '{' struct_declaration+ '}' | ('struct' | 'union') identifier
        mark = self._mark()
        if (
            (_tmp_15 := self._tmp_15())
            and
            (opt := self.identifier(),)
            and
            (literal := self.expect('{'))
            and
            (_loop1_16 := self._loop1_16())
            and
            (literal_1 := self.expect('}'))
        ):
            return [_tmp_15, opt, literal, _loop1_16, literal_1]
        self._reset(mark)
        if (
            (_tmp_17 := self._tmp_17())
            and
            (identifier := self.identifier())
        ):
            return [_tmp_17, identifier]
        self._reset(mark)
        return None

    @memoize
    def struct_declaration(self) -> Optional[Any]:
        # struct_declaration: specifier_qualifier+ ','.struct_declarator+ ';' | static_assert_declaration
        mark = self._mark()
        if (
            (_loop1_18 := self._loop1_18())
            and
            (_gather_19 := self._gather_19())
            and
            (literal := self.expect(';'))
        ):
            return [_loop1_18, _gather_19, literal]
        self._reset(mark)
        if (
            (static_assert_declaration := self.static_assert_declaration())
        ):
            return static_assert_declaration
        self._reset(mark)
        return None

    @memoize
    def specifier_qualifier(self) -> Optional[Any]:
        # specifier_qualifier: type_specifier | type_qualifier
        mark = self._mark()
        if (
            (type_specifier := self.type_specifier())
        ):
            return type_specifier
        self._reset(mark)
        if (
            (type_qualifier := self.type_qualifier())
        ):
            return type_qualifier
        self._reset(mark)
        return None

    @memoize
    def struct_declarator(self) -> Optional[Any]:
        # struct_declarator: declarator? ':' constant_expression | declarator
        mark = self._mark()
        if (
            (opt := self.declarator(),)
            and
            (literal := self.expect(':'))
            and
            (constant_expression := self.constant_expression())
        ):
            return [opt, literal, constant_expression]
        self._reset(mark)
        if (
            (declarator := self.declarator())
        ):
            return declarator
        self._reset(mark)
        return None

    @memoize
    def enum_specifier(self) -> Optional[Any]:
        # enum_specifier: 'enum' identifier? '{' ','.enumerator+ ','? '}' | 'enum' identifier
        mark = self._mark()
        if (
            (literal := self.expect('enum'))
            and
            (opt := self.identifier(),)
            and
            (literal_1 := self.expect('{'))
            and
            (_gather_21 := self._gather_21())
            and
            (opt_1 := self.expect(','),)
            and
            (literal_2 := self.expect('}'))
        ):
            return [literal, opt, literal_1, _gather_21, opt_1, literal_2]
        self._reset(mark)
        if (
            (literal := self.expect('enum'))
            and
            (identifier := self.identifier())
        ):
            return [literal, identifier]
        self._reset(mark)
        return None

    @memoize
    def enumerator(self) -> Optional[Any]:
        # enumerator: enumeration_constant ['=' constant_expression]
        mark = self._mark()
        if (
            (enumeration_constant := self.enumeration_constant())
            and
            (opt := self._tmp_23(),)
        ):
            return [enumeration_constant, opt]
        self._reset(mark)
        return None

    @memoize
    def atomic_type_specifier(self) -> Optional[Any]:
        # atomic_type_specifier: '_Atomic' '(' type_name ')'
        mark = self._mark()
        if (
            (literal := self.expect('_Atomic'))
            and
            (literal_1 := self.expect('('))
            and
            (type_name := self.type_name())
            and
            (literal_2 := self.expect(')'))
        ):
            return [literal, literal_1, type_name, literal_2]
        self._reset(mark)
        return None

    @memoize
    def type_qualifier(self) -> Optional[Any]:
        # type_qualifier: 'const' | 'restrict' | 'volatile' | '_Atomic'
        mark = self._mark()
        if (
            (literal := self.expect('const'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('restrict'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('volatile'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('_Atomic'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def function_specifier(self) -> Optional[Any]:
        # function_specifier: 'inline' | '_Noreturn'
        mark = self._mark()
        if (
            (literal := self.expect('inline'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('_Noreturn'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def alignment_specifier(self) -> Optional[Any]:
        # alignment_specifier: '_Alignas' '(' (type_name | constant_expression) ')'
        mark = self._mark()
        if (
            (literal := self.expect('_Alignas'))
            and
            (literal_1 := self.expect('('))
            and
            (_tmp_24 := self._tmp_24())
            and
            (literal_2 := self.expect(')'))
        ):
            return [literal, literal_1, _tmp_24, literal_2]
        self._reset(mark)
        return None

    @memoize
    def declarator(self) -> Optional[Any]:
        # declarator: pointer? direct_declarator
        mark = self._mark()
        if (
            (opt := self.pointer(),)
            and
            (direct_declarator := self.direct_declarator())
        ):
            return [opt, direct_declarator]
        self._reset(mark)
        return None

    @memoize_left_rec
    def direct_declarator(self) -> Optional[Any]:
        # direct_declarator: identifier | '(' declarator ')' | direct_declarator '[' type_qualifier* assignment_expression? ']' | direct_declarator '[' 'static' type_qualifier* assignment_expression ']' | direct_declarator '[' type_qualifier+ 'static' assignment_expression ']' | direct_declarator '[' type_qualifier+ '*' ']' | direct_declarator '(' parameter_type_list ')' | direct_declarator '(' ','.identifier+? ')'
        mark = self._mark()
        if (
            (identifier := self.identifier())
        ):
            return identifier
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (declarator := self.declarator())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, declarator, literal_1]
        self._reset(mark)
        if (
            (direct_declarator := self.direct_declarator())
            and
            (literal := self.expect('['))
            and
            (_loop0_25 := self._loop0_25(),)
            and
            (opt := self.assignment_expression(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [direct_declarator, literal, _loop0_25, opt, literal_1]
        self._reset(mark)
        if (
            (direct_declarator := self.direct_declarator())
            and
            (literal := self.expect('['))
            and
            (literal_1 := self.expect('static'))
            and
            (_loop0_26 := self._loop0_26(),)
            and
            (assignment_expression := self.assignment_expression())
            and
            (literal_2 := self.expect(']'))
        ):
            return [direct_declarator, literal, literal_1, _loop0_26, assignment_expression, literal_2]
        self._reset(mark)
        if (
            (direct_declarator := self.direct_declarator())
            and
            (literal := self.expect('['))
            and
            (_loop1_27 := self._loop1_27())
            and
            (literal_1 := self.expect('static'))
            and
            (assignment_expression := self.assignment_expression())
            and
            (literal_2 := self.expect(']'))
        ):
            return [direct_declarator, literal, _loop1_27, literal_1, assignment_expression, literal_2]
        self._reset(mark)
        if (
            (direct_declarator := self.direct_declarator())
            and
            (literal := self.expect('['))
            and
            (_loop1_28 := self._loop1_28())
            and
            (literal_1 := self.expect('*'))
            and
            (literal_2 := self.expect(']'))
        ):
            return [direct_declarator, literal, _loop1_28, literal_1, literal_2]
        self._reset(mark)
        if (
            (direct_declarator := self.direct_declarator())
            and
            (literal := self.expect('('))
            and
            (parameter_type_list := self.parameter_type_list())
            and
            (literal_1 := self.expect(')'))
        ):
            return [direct_declarator, literal, parameter_type_list, literal_1]
        self._reset(mark)
        if (
            (direct_declarator := self.direct_declarator())
            and
            (literal := self.expect('('))
            and
            (opt := self._gather_29(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [direct_declarator, literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def pointer(self) -> Optional[Any]:
        # pointer: '*' type_qualifier* pointer?
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (_loop0_31 := self._loop0_31(),)
            and
            (opt := self.pointer(),)
        ):
            return [literal, _loop0_31, opt]
        self._reset(mark)
        return None

    @memoize
    def parameter_type_list(self) -> Optional[Any]:
        # parameter_type_list: ','.parameter_declaration+ [',' '...']
        mark = self._mark()
        if (
            (_gather_32 := self._gather_32())
            and
            (opt := self._tmp_34(),)
        ):
            return [_gather_32, opt]
        self._reset(mark)
        return None

    @memoize
    def parameter_declaration(self) -> Optional[Any]:
        # parameter_declaration: declaration_specifier+ declarator | declaration_specifier+ abstract_declarator?
        mark = self._mark()
        if (
            (_loop1_35 := self._loop1_35())
            and
            (declarator := self.declarator())
        ):
            return [_loop1_35, declarator]
        self._reset(mark)
        if (
            (_loop1_36 := self._loop1_36())
            and
            (opt := self.abstract_declarator(),)
        ):
            return [_loop1_36, opt]
        self._reset(mark)
        return None

    @memoize
    def type_name(self) -> Optional[Any]:
        # type_name: specifier_qualifier+ abstract_declarator?
        mark = self._mark()
        if (
            (_loop1_37 := self._loop1_37())
            and
            (opt := self.abstract_declarator(),)
        ):
            return [_loop1_37, opt]
        self._reset(mark)
        return None

    @memoize
    def abstract_declarator(self) -> Optional[Any]:
        # abstract_declarator: pointer? direct_abstract_declarator | pointer
        mark = self._mark()
        if (
            (opt := self.pointer(),)
            and
            (direct_abstract_declarator := self.direct_abstract_declarator())
        ):
            return [opt, direct_abstract_declarator]
        self._reset(mark)
        if (
            (pointer := self.pointer())
        ):
            return pointer
        self._reset(mark)
        return None

    @memoize_left_rec
    def direct_abstract_declarator(self) -> Optional[Any]:
        # direct_abstract_declarator: '(' abstract_declarator ')' | direct_abstract_declarator? '[' type_qualifier* assignment_expression? ']' | direct_abstract_declarator? '[' 'static' type_qualifier* assignment_expression ']' | direct_abstract_declarator? '[' type_qualifier+ 'static' assignment_expression ']' | direct_abstract_declarator? '[' '*' ']' | direct_abstract_declarator? '(' parameter_type_list? ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (abstract_declarator := self.abstract_declarator())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, abstract_declarator, literal_1]
        self._reset(mark)
        if (
            (opt := self.direct_abstract_declarator(),)
            and
            (literal := self.expect('['))
            and
            (_loop0_38 := self._loop0_38(),)
            and
            (opt_1 := self.assignment_expression(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [opt, literal, _loop0_38, opt_1, literal_1]
        self._reset(mark)
        if (
            (opt := self.direct_abstract_declarator(),)
            and
            (literal := self.expect('['))
            and
            (literal_1 := self.expect('static'))
            and
            (_loop0_39 := self._loop0_39(),)
            and
            (assignment_expression := self.assignment_expression())
            and
            (literal_2 := self.expect(']'))
        ):
            return [opt, literal, literal_1, _loop0_39, assignment_expression, literal_2]
        self._reset(mark)
        if (
            (opt := self.direct_abstract_declarator(),)
            and
            (literal := self.expect('['))
            and
            (_loop1_40 := self._loop1_40())
            and
            (literal_1 := self.expect('static'))
            and
            (assignment_expression := self.assignment_expression())
            and
            (literal_2 := self.expect(']'))
        ):
            return [opt, literal, _loop1_40, literal_1, assignment_expression, literal_2]
        self._reset(mark)
        if (
            (opt := self.direct_abstract_declarator(),)
            and
            (literal := self.expect('['))
            and
            (literal_1 := self.expect('*'))
            and
            (literal_2 := self.expect(']'))
        ):
            return [opt, literal, literal_1, literal_2]
        self._reset(mark)
        if (
            (opt := self.direct_abstract_declarator(),)
            and
            (literal := self.expect('('))
            and
            (opt_1 := self.parameter_type_list(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [opt, literal, opt_1, literal_1]
        self._reset(mark)
        return None

    @memoize
    def typedef_name(self) -> Optional[Any]:
        # typedef_name: identifier
        mark = self._mark()
        if (
            (identifier := self.identifier())
        ):
            return identifier
        self._reset(mark)
        return None

    @memoize
    def initializer(self) -> Optional[Any]:
        # initializer: assignment_expression | '{' initializer_list ','? '}'
        mark = self._mark()
        if (
            (assignment_expression := self.assignment_expression())
        ):
            return assignment_expression
        self._reset(mark)
        if (
            (literal := self.expect('{'))
            and
            (initializer_list := self.initializer_list())
            and
            (opt := self.expect(','),)
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, initializer_list, opt, literal_1]
        self._reset(mark)
        return None

    @memoize_left_rec
    def initializer_list(self) -> Optional[Any]:
        # initializer_list: initializer_list? [designator+ '='] initializer
        mark = self._mark()
        if (
            (opt := self.initializer_list(),)
            and
            (opt_1 := self._tmp_41(),)
            and
            (initializer := self.initializer())
        ):
            return [opt, opt_1, initializer]
        self._reset(mark)
        return None

    @memoize
    def designator(self) -> Optional[Any]:
        # designator: '[' constant_expression ']' | '.' identifier
        mark = self._mark()
        if (
            (literal := self.expect('['))
            and
            (constant_expression := self.constant_expression())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, constant_expression, literal_1]
        self._reset(mark)
        if (
            (literal := self.expect('.'))
            and
            (identifier := self.identifier())
        ):
            return [literal, identifier]
        self._reset(mark)
        return None

    @memoize
    def static_assert_declaration(self) -> Optional[Any]:
        # static_assert_declaration: '_Static_assert' '(' constant_expression ',' string_literal ')' ';'
        mark = self._mark()
        if (
            (literal := self.expect('_Static_assert'))
            and
            (literal_1 := self.expect('('))
            and
            (constant_expression := self.constant_expression())
            and
            (literal_2 := self.expect(','))
            and
            (string_literal := self.string_literal())
            and
            (literal_3 := self.expect(')'))
            and
            (literal_4 := self.expect(';'))
        ):
            return [literal, literal_1, constant_expression, literal_2, string_literal, literal_3, literal_4]
        self._reset(mark)
        return None

    @memoize
    def primary_expression(self) -> Optional[Any]:
        # primary_expression: identifier | constant | string_literal | '(' expression ')' | generic_selection
        mark = self._mark()
        if (
            (identifier := self.identifier())
        ):
            return identifier
        self._reset(mark)
        if (
            (constant := self.constant())
        ):
            return constant
        self._reset(mark)
        if (
            (string_literal := self.string_literal())
        ):
            return string_literal
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, expression, literal_1]
        self._reset(mark)
        if (
            (generic_selection := self.generic_selection())
        ):
            return generic_selection
        self._reset(mark)
        return None

    @memoize
    def generic_selection(self) -> Optional[Any]:
        # generic_selection: '_Generic' '(' assignment_expression ',' ','.generic_association+ ')'
        mark = self._mark()
        if (
            (literal := self.expect('_Generic'))
            and
            (literal_1 := self.expect('('))
            and
            (assignment_expression := self.assignment_expression())
            and
            (literal_2 := self.expect(','))
            and
            (_gather_42 := self._gather_42())
            and
            (literal_3 := self.expect(')'))
        ):
            return [literal, literal_1, assignment_expression, literal_2, _gather_42, literal_3]
        self._reset(mark)
        return None

    @memoize
    def generic_association(self) -> Optional[Any]:
        # generic_association: (type_name | 'default') ':' assignment_expression
        mark = self._mark()
        if (
            (_tmp_44 := self._tmp_44())
            and
            (literal := self.expect(':'))
            and
            (assignment_expression := self.assignment_expression())
        ):
            return [_tmp_44, literal, assignment_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def postfix_expression(self) -> Optional[Any]:
        # postfix_expression: primary_expression | postfix_expression '[' expression ']' | postfix_expression '(' ','.assignment_expression+? ')' | postfix_expression '.' identifier | postfix_expression '->' identifier | postfix_expression '++' | postfix_expression '--' | '(' type_name ')' '{' initializer_list ','? '}'
        mark = self._mark()
        if (
            (primary_expression := self.primary_expression())
        ):
            return primary_expression
        self._reset(mark)
        if (
            (postfix_expression := self.postfix_expression())
            and
            (literal := self.expect('['))
            and
            (expression := self.expression())
            and
            (literal_1 := self.expect(']'))
        ):
            return [postfix_expression, literal, expression, literal_1]
        self._reset(mark)
        if (
            (postfix_expression := self.postfix_expression())
            and
            (literal := self.expect('('))
            and
            (opt := self._gather_45(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [postfix_expression, literal, opt, literal_1]
        self._reset(mark)
        if (
            (postfix_expression := self.postfix_expression())
            and
            (literal := self.expect('.'))
            and
            (identifier := self.identifier())
        ):
            return [postfix_expression, literal, identifier]
        self._reset(mark)
        if (
            (postfix_expression := self.postfix_expression())
            and
            (literal := self.expect('->'))
            and
            (identifier := self.identifier())
        ):
            return [postfix_expression, literal, identifier]
        self._reset(mark)
        if (
            (postfix_expression := self.postfix_expression())
            and
            (literal := self.expect('++'))
        ):
            return [postfix_expression, literal]
        self._reset(mark)
        if (
            (postfix_expression := self.postfix_expression())
            and
            (literal := self.expect('--'))
        ):
            return [postfix_expression, literal]
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (type_name := self.type_name())
            and
            (literal_1 := self.expect(')'))
            and
            (literal_2 := self.expect('{'))
            and
            (initializer_list := self.initializer_list())
            and
            (opt := self.expect(','),)
            and
            (literal_3 := self.expect('}'))
        ):
            return [literal, type_name, literal_1, literal_2, initializer_list, opt, literal_3]
        self._reset(mark)
        return None

    @memoize
    def unary_expression(self) -> Optional[Any]:
        # unary_expression: postfix_expression | '++' unary_expression | '--' unary_expression | unary_operator cast_expression | 'sizeof' unary_expression | 'sizeof' '(' type_name ')' | '_Alignof' '(' type_name ')'
        mark = self._mark()
        if (
            (postfix_expression := self.postfix_expression())
        ):
            return postfix_expression
        self._reset(mark)
        if (
            (literal := self.expect('++'))
            and
            (unary_expression := self.unary_expression())
        ):
            return [literal, unary_expression]
        self._reset(mark)
        if (
            (literal := self.expect('--'))
            and
            (unary_expression := self.unary_expression())
        ):
            return [literal, unary_expression]
        self._reset(mark)
        if (
            (unary_operator := self.unary_operator())
            and
            (cast_expression := self.cast_expression())
        ):
            return [unary_operator, cast_expression]
        self._reset(mark)
        if (
            (literal := self.expect('sizeof'))
            and
            (unary_expression := self.unary_expression())
        ):
            return [literal, unary_expression]
        self._reset(mark)
        if (
            (literal := self.expect('sizeof'))
            and
            (literal_1 := self.expect('('))
            and
            (type_name := self.type_name())
            and
            (literal_2 := self.expect(')'))
        ):
            return [literal, literal_1, type_name, literal_2]
        self._reset(mark)
        if (
            (literal := self.expect('_Alignof'))
            and
            (literal_1 := self.expect('('))
            and
            (type_name := self.type_name())
            and
            (literal_2 := self.expect(')'))
        ):
            return [literal, literal_1, type_name, literal_2]
        self._reset(mark)
        return None

    @memoize
    def unary_operator(self) -> Optional[Any]:
        # unary_operator: '&' | '*' | '+' | '-' | '~' | '!'
        mark = self._mark()
        if (
            (literal := self.expect('&'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('*'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('+'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('-'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('~'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('!'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def cast_expression(self) -> Optional[Any]:
        # cast_expression: unary_expression | '(' type_name ')' cast_expression
        mark = self._mark()
        if (
            (unary_expression := self.unary_expression())
        ):
            return unary_expression
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (type_name := self.type_name())
            and
            (literal_1 := self.expect(')'))
            and
            (cast_expression := self.cast_expression())
        ):
            return [literal, type_name, literal_1, cast_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def multiplicative_expression(self) -> Optional[Any]:
        # multiplicative_expression: [multiplicative_expression ('*' | '/' | '%')] cast_expression
        mark = self._mark()
        if (
            (opt := self._tmp_47(),)
            and
            (cast_expression := self.cast_expression())
        ):
            return [opt, cast_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def additive_expression(self) -> Optional[Any]:
        # additive_expression: [additive_expression ('+' | '-')] multiplicative_expression
        mark = self._mark()
        if (
            (opt := self._tmp_48(),)
            and
            (multiplicative_expression := self.multiplicative_expression())
        ):
            return [opt, multiplicative_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def shift_expression(self) -> Optional[Any]:
        # shift_expression: [shift_expression ('<<' | '>>')] additive_expression
        mark = self._mark()
        if (
            (opt := self._tmp_49(),)
            and
            (additive_expression := self.additive_expression())
        ):
            return [opt, additive_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def relational_expression(self) -> Optional[Any]:
        # relational_expression: [relational_expression ('<' | '>' | '<=' | '>=')] shift_expression
        mark = self._mark()
        if (
            (opt := self._tmp_50(),)
            and
            (shift_expression := self.shift_expression())
        ):
            return [opt, shift_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def equality_expression(self) -> Optional[Any]:
        # equality_expression: [equality_expression ('==' | '!=')] relational_expression
        mark = self._mark()
        if (
            (opt := self._tmp_51(),)
            and
            (relational_expression := self.relational_expression())
        ):
            return [opt, relational_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def and_expression(self) -> Optional[Any]:
        # and_expression: [and_expression '&'] equality_expression
        mark = self._mark()
        if (
            (opt := self._tmp_52(),)
            and
            (equality_expression := self.equality_expression())
        ):
            return [opt, equality_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def xor_expression(self) -> Optional[Any]:
        # xor_expression: [xor_expression '^'] and_expression
        mark = self._mark()
        if (
            (opt := self._tmp_53(),)
            and
            (and_expression := self.and_expression())
        ):
            return [opt, and_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def or_expression(self) -> Optional[Any]:
        # or_expression: [or_expression '|'] xor_expression
        mark = self._mark()
        if (
            (opt := self._tmp_54(),)
            and
            (xor_expression := self.xor_expression())
        ):
            return [opt, xor_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def logand_expression(self) -> Optional[Any]:
        # logand_expression: [logand_expression '&&'] or_expression
        mark = self._mark()
        if (
            (opt := self._tmp_55(),)
            and
            (or_expression := self.or_expression())
        ):
            return [opt, or_expression]
        self._reset(mark)
        return None

    @memoize_left_rec
    def logor_expression(self) -> Optional[Any]:
        # logor_expression: [logor_expression '||'] logand_expression
        mark = self._mark()
        if (
            (opt := self._tmp_56(),)
            and
            (logand_expression := self.logand_expression())
        ):
            return [opt, logand_expression]
        self._reset(mark)
        return None

    @memoize
    def conditional_expression(self) -> Optional[Any]:
        # conditional_expression: logor_expression ['?' expression ':' conditional_expression]
        mark = self._mark()
        if (
            (logor_expression := self.logor_expression())
            and
            (opt := self._tmp_57(),)
        ):
            return [logor_expression, opt]
        self._reset(mark)
        return None

    @memoize
    def assignment_expression(self) -> Optional[Any]:
        # assignment_expression: conditional_expression | unary_expression assignment_operator assignment_expression
        mark = self._mark()
        if (
            (conditional_expression := self.conditional_expression())
        ):
            return conditional_expression
        self._reset(mark)
        if (
            (unary_expression := self.unary_expression())
            and
            (assignment_operator := self.assignment_operator())
            and
            (assignment_expression := self.assignment_expression())
        ):
            return [unary_expression, assignment_operator, assignment_expression]
        self._reset(mark)
        return None

    @memoize
    def assignment_operator(self) -> Optional[Any]:
        # assignment_operator: '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|='
        mark = self._mark()
        if (
            (literal := self.expect('='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('*='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('/='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('%='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('+='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('-='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('<<='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>>='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('&='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('^='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('|='))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: ','.assignment_expression+
        mark = self._mark()
        if (
            (_gather_58 := self._gather_58())
        ):
            return _gather_58
        self._reset(mark)
        return None

    @memoize
    def constant_expression(self) -> Optional[Any]:
        # constant_expression: conditional_expression
        mark = self._mark()
        if (
            (conditional_expression := self.conditional_expression())
        ):
            return conditional_expression
        self._reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: external_declaration
        mark = self._mark()
        children = []
        while (
            (external_declaration := self.external_declaration())
        ):
            children.append(external_declaration)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_2(self) -> Optional[Any]:
        # _loop1_2: any1
        mark = self._mark()
        children = []
        while (
            (any1 := self.any1())
        ):
            children.append(any1)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: any
        mark = self._mark()
        children = []
        while (
            (any := self.any())
        ):
            children.append(any)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: any
        mark = self._mark()
        children = []
        while (
            (any := self.any())
        ):
            children.append(any)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: any
        mark = self._mark()
        children = []
        while (
            (any := self.any())
        ):
            children.append(any)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: ';' | ')' | '}' | ']'
        mark = self._mark()
        if (
            (literal := self.expect(';'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect(')'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('}'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect(']'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop1_7(self) -> Optional[Any]:
        # _loop1_7: declaration_specifier
        mark = self._mark()
        children = []
        while (
            (declaration_specifier := self.declaration_specifier())
        ):
            children.append(declaration_specifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_8(self) -> Optional[Any]:
        # _loop0_8: declaration
        mark = self._mark()
        children = []
        while (
            (declaration := self.declaration())
        ):
            children.append(declaration)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_9(self) -> Optional[Any]:
        # _loop0_9: block_item
        mark = self._mark()
        children = []
        while (
            (block_item := self.block_item())
        ):
            children.append(block_item)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_10(self) -> Optional[Any]:
        # _loop1_10: declaration_specifier
        mark = self._mark()
        children = []
        while (
            (declaration_specifier := self.declaration_specifier())
        ):
            children.append(declaration_specifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_12(self) -> Optional[Any]:
        # _loop0_12: ',' (init_declarator)
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.init_declarator())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_11(self) -> Optional[Any]:
        # _gather_11: (init_declarator) _loop0_12
        mark = self._mark()
        if (
            (elem := self.init_declarator())
            is not None
            and
            (seq := self._loop0_12())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_13(self) -> Optional[Any]:
        # _tmp_13: 'typedef' | 'extern' | 'static'
        mark = self._mark()
        if (
            (literal := self.expect('typedef'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('extern'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('static'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: '_Thread_local' | 'auto' | 'register'
        mark = self._mark()
        if (
            (literal := self.expect('_Thread_local'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('auto'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('register'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: 'struct' | 'union'
        mark = self._mark()
        if (
            (literal := self.expect('struct'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('union'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop1_16(self) -> Optional[Any]:
        # _loop1_16: struct_declaration
        mark = self._mark()
        children = []
        while (
            (struct_declaration := self.struct_declaration())
        ):
            children.append(struct_declaration)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_17(self) -> Optional[Any]:
        # _tmp_17: 'struct' | 'union'
        mark = self._mark()
        if (
            (literal := self.expect('struct'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('union'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop1_18(self) -> Optional[Any]:
        # _loop1_18: specifier_qualifier
        mark = self._mark()
        children = []
        while (
            (specifier_qualifier := self.specifier_qualifier())
        ):
            children.append(specifier_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_20(self) -> Optional[Any]:
        # _loop0_20: ',' struct_declarator
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.struct_declarator())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_19(self) -> Optional[Any]:
        # _gather_19: struct_declarator _loop0_20
        mark = self._mark()
        if (
            (elem := self.struct_declarator())
            is not None
            and
            (seq := self._loop0_20())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_22(self) -> Optional[Any]:
        # _loop0_22: ',' enumerator
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.enumerator())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_21(self) -> Optional[Any]:
        # _gather_21: enumerator _loop0_22
        mark = self._mark()
        if (
            (elem := self.enumerator())
            is not None
            and
            (seq := self._loop0_22())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_23(self) -> Optional[Any]:
        # _tmp_23: '=' constant_expression
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (constant_expression := self.constant_expression())
        ):
            return [literal, constant_expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_24(self) -> Optional[Any]:
        # _tmp_24: type_name | constant_expression
        mark = self._mark()
        if (
            (type_name := self.type_name())
        ):
            return type_name
        self._reset(mark)
        if (
            (constant_expression := self.constant_expression())
        ):
            return constant_expression
        self._reset(mark)
        return None

    @memoize
    def _loop0_25(self) -> Optional[Any]:
        # _loop0_25: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_26(self) -> Optional[Any]:
        # _loop0_26: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_27(self) -> Optional[Any]:
        # _loop1_27: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_28(self) -> Optional[Any]:
        # _loop1_28: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_30(self) -> Optional[Any]:
        # _loop0_30: ',' identifier
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.identifier())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_29(self) -> Optional[Any]:
        # _gather_29: identifier _loop0_30
        mark = self._mark()
        if (
            (elem := self.identifier())
            is not None
            and
            (seq := self._loop0_30())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_31(self) -> Optional[Any]:
        # _loop0_31: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_33(self) -> Optional[Any]:
        # _loop0_33: ',' parameter_declaration
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.parameter_declaration())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_32(self) -> Optional[Any]:
        # _gather_32: parameter_declaration _loop0_33
        mark = self._mark()
        if (
            (elem := self.parameter_declaration())
            is not None
            and
            (seq := self._loop0_33())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_34(self) -> Optional[Any]:
        # _tmp_34: ',' '...'
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('...'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _loop1_35(self) -> Optional[Any]:
        # _loop1_35: declaration_specifier
        mark = self._mark()
        children = []
        while (
            (declaration_specifier := self.declaration_specifier())
        ):
            children.append(declaration_specifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_36(self) -> Optional[Any]:
        # _loop1_36: declaration_specifier
        mark = self._mark()
        children = []
        while (
            (declaration_specifier := self.declaration_specifier())
        ):
            children.append(declaration_specifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_37(self) -> Optional[Any]:
        # _loop1_37: specifier_qualifier
        mark = self._mark()
        children = []
        while (
            (specifier_qualifier := self.specifier_qualifier())
        ):
            children.append(specifier_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_38(self) -> Optional[Any]:
        # _loop0_38: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_39(self) -> Optional[Any]:
        # _loop0_39: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_40(self) -> Optional[Any]:
        # _loop1_40: type_qualifier
        mark = self._mark()
        children = []
        while (
            (type_qualifier := self.type_qualifier())
        ):
            children.append(type_qualifier)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_41(self) -> Optional[Any]:
        # _tmp_41: designator+ '='
        mark = self._mark()
        if (
            (_loop1_60 := self._loop1_60())
            and
            (literal := self.expect('='))
        ):
            return [_loop1_60, literal]
        self._reset(mark)
        return None

    @memoize
    def _loop0_43(self) -> Optional[Any]:
        # _loop0_43: ',' generic_association
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.generic_association())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_42(self) -> Optional[Any]:
        # _gather_42: generic_association _loop0_43
        mark = self._mark()
        if (
            (elem := self.generic_association())
            is not None
            and
            (seq := self._loop0_43())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_44(self) -> Optional[Any]:
        # _tmp_44: type_name | 'default'
        mark = self._mark()
        if (
            (type_name := self.type_name())
        ):
            return type_name
        self._reset(mark)
        if (
            (literal := self.expect('default'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop0_46(self) -> Optional[Any]:
        # _loop0_46: ',' assignment_expression
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.assignment_expression())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_45(self) -> Optional[Any]:
        # _gather_45: assignment_expression _loop0_46
        mark = self._mark()
        if (
            (elem := self.assignment_expression())
            is not None
            and
            (seq := self._loop0_46())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_47(self) -> Optional[Any]:
        # _tmp_47: multiplicative_expression ('*' | '/' | '%')
        mark = self._mark()
        if (
            (multiplicative_expression := self.multiplicative_expression())
            and
            (_tmp_61 := self._tmp_61())
        ):
            return [multiplicative_expression, _tmp_61]
        self._reset(mark)
        return None

    @memoize
    def _tmp_48(self) -> Optional[Any]:
        # _tmp_48: additive_expression ('+' | '-')
        mark = self._mark()
        if (
            (additive_expression := self.additive_expression())
            and
            (_tmp_62 := self._tmp_62())
        ):
            return [additive_expression, _tmp_62]
        self._reset(mark)
        return None

    @memoize
    def _tmp_49(self) -> Optional[Any]:
        # _tmp_49: shift_expression ('<<' | '>>')
        mark = self._mark()
        if (
            (shift_expression := self.shift_expression())
            and
            (_tmp_63 := self._tmp_63())
        ):
            return [shift_expression, _tmp_63]
        self._reset(mark)
        return None

    @memoize
    def _tmp_50(self) -> Optional[Any]:
        # _tmp_50: relational_expression ('<' | '>' | '<=' | '>=')
        mark = self._mark()
        if (
            (relational_expression := self.relational_expression())
            and
            (_tmp_64 := self._tmp_64())
        ):
            return [relational_expression, _tmp_64]
        self._reset(mark)
        return None

    @memoize
    def _tmp_51(self) -> Optional[Any]:
        # _tmp_51: equality_expression ('==' | '!=')
        mark = self._mark()
        if (
            (equality_expression := self.equality_expression())
            and
            (_tmp_65 := self._tmp_65())
        ):
            return [equality_expression, _tmp_65]
        self._reset(mark)
        return None

    @memoize
    def _tmp_52(self) -> Optional[Any]:
        # _tmp_52: and_expression '&'
        mark = self._mark()
        if (
            (and_expression := self.and_expression())
            and
            (literal := self.expect('&'))
        ):
            return [and_expression, literal]
        self._reset(mark)
        return None

    @memoize
    def _tmp_53(self) -> Optional[Any]:
        # _tmp_53: xor_expression '^'
        mark = self._mark()
        if (
            (xor_expression := self.xor_expression())
            and
            (literal := self.expect('^'))
        ):
            return [xor_expression, literal]
        self._reset(mark)
        return None

    @memoize
    def _tmp_54(self) -> Optional[Any]:
        # _tmp_54: or_expression '|'
        mark = self._mark()
        if (
            (or_expression := self.or_expression())
            and
            (literal := self.expect('|'))
        ):
            return [or_expression, literal]
        self._reset(mark)
        return None

    @memoize
    def _tmp_55(self) -> Optional[Any]:
        # _tmp_55: logand_expression '&&'
        mark = self._mark()
        if (
            (logand_expression := self.logand_expression())
            and
            (literal := self.expect('&&'))
        ):
            return [logand_expression, literal]
        self._reset(mark)
        return None

    @memoize
    def _tmp_56(self) -> Optional[Any]:
        # _tmp_56: logor_expression '||'
        mark = self._mark()
        if (
            (logor_expression := self.logor_expression())
            and
            (literal := self.expect('||'))
        ):
            return [logor_expression, literal]
        self._reset(mark)
        return None

    @memoize
    def _tmp_57(self) -> Optional[Any]:
        # _tmp_57: '?' expression ':' conditional_expression
        mark = self._mark()
        if (
            (literal := self.expect('?'))
            and
            (expression := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (conditional_expression := self.conditional_expression())
        ):
            return [literal, expression, literal_1, conditional_expression]
        self._reset(mark)
        return None

    @memoize
    def _loop0_59(self) -> Optional[Any]:
        # _loop0_59: ',' assignment_expression
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.assignment_expression())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_58(self) -> Optional[Any]:
        # _gather_58: assignment_expression _loop0_59
        mark = self._mark()
        if (
            (elem := self.assignment_expression())
            is not None
            and
            (seq := self._loop0_59())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop1_60(self) -> Optional[Any]:
        # _loop1_60: designator
        mark = self._mark()
        children = []
        while (
            (designator := self.designator())
        ):
            children.append(designator)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_61(self) -> Optional[Any]:
        # _tmp_61: '*' | '/' | '%'
        mark = self._mark()
        if (
            (literal := self.expect('*'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('/'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('%'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_62(self) -> Optional[Any]:
        # _tmp_62: '+' | '-'
        mark = self._mark()
        if (
            (literal := self.expect('+'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('-'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_63(self) -> Optional[Any]:
        # _tmp_63: '<<' | '>>'
        mark = self._mark()
        if (
            (literal := self.expect('<<'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>>'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_64(self) -> Optional[Any]:
        # _tmp_64: '<' | '>' | '<=' | '>='
        mark = self._mark()
        if (
            (literal := self.expect('<'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('<='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>='))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_65(self) -> Optional[Any]:
        # _tmp_65: '==' | '!='
        mark = self._mark()
        if (
            (literal := self.expect('=='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('!='))
        ):
            return literal
        self._reset(mark)
        return None

    KEYWORDS = ('case', 'default', 'if', 'else', 'switch', 'while', 'do', 'for', 'goto', 'continue', 'break', 'return', 'typedef', 'extern', 'static', '_Thread_local', 'auto', 'register', 'void', 'char', 'short', 'int', 'long', 'float', 'double', 'signed', 'unsigned', '_Bool', '_Complex', '__attribute__', 'struct', 'union', 'enum', '_Atomic', 'const', 'restrict', 'volatile', 'inline', '_Noreturn', '_Alignas', '_Static_assert', '_Generic', 'sizeof', '_Alignof')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
