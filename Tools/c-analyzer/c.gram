@subheader """\
from cast import Name
"""

start: external_declaration* ENDMARKER

any: any1+
any1:
    | n=NAME { Name(n.string) }
    | n=NUMBER {n.string}
    | n=STRING {n.string}
    | '(' ~ a=any* ')' {a}
    | '{' ~ a=any* '}' {a}
    | '[' ~ a=any* ']' {a}
    | !(';' | ')' | '}' | ']') OP
    | ';'

identifier: n=NAME { Name(n.string) }
string_literal: STRING
constant: NUMBER | STRING
enumeration_constant: NAME


# A.2.4 External definitions

external_declaration:
    | function_definition
    | declaration

function_definition:
    | declaration_specifier+ declarator declaration* compound_statement


# A.2.3 Statements

statement:
    | labeled_statement
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement

labeled_statement:
    | 'case' ~ constant_expression ':' statement
    | 'default' ~ ':' statement
    | identifier ':' statement

compound_statement:
    | '{' block_item* '}'

block_item:
    | declaration
    | statement

expression_statement:
    | [expression] ';'


selection_statement:
    | 'if' '(' expression ')' statement 'else' statement
    | 'if' '(' expression ')' statement
    | 'switch' '(' expression ')' statement

iteration_statement:
    | 'while' ~ '(' expression ')' statement
    | 'do' ~ statement 'while' '(' expression ')' ';'
    | 'for' '(' [expression] ';' [expression] ';' [expression] ')' statement
    | 'for' '(' declaration [expression] ';' [expression] ')' statement

jump_statement:
    | 'goto' ~ identifier ';'
    | 'continue' ~ ';'
    | 'break' ~ ';'
    | 'return' ~ [expression] ';'


# A.2.2 Declarations

declaration:
    | declaration_specifier+ [','.(init_declarator)+] ';'
    | static_assert_declaration

init_declarator:
    | declarator '=' initializer
    | declarator

declaration_specifier:
    | storage_class_specifier
    | type_specifier
    | type_qualifier
    | function_specifier
    | alignment_specifier

storage_class_specifier[str]:
    | a=('typedef' | 'extern' | 'static') { a.string }
    | a=('_Thread_local' | 'auto' | 'register') { a.string }

type_specifier:
    | 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double'
    | 'signed' | 'unsigned' | '_Bool' | '_Complex'
    | atomic_type_specifier
    | struct_or_union_specifier
    | enum_specifier
    | typedef_name
    | '__attribute__' '(' any ')'

struct_or_union_specifier:
    | ('struct' | 'union') [identifier] '{' struct_declaration+ '}'
    | ('struct' | 'union') identifier

struct_declaration:
    | specifier_qualifier+ ','.struct_declarator+ ';'
    | static_assert_declaration

specifier_qualifier:
    | type_specifier
    | type_qualifier

struct_declarator:
    | [declarator] ':' constant_expression
    | declarator

enum_specifier:
    | 'enum' [identifier] '{' ','.enumerator+ [','] '}'
    | 'enum' identifier

enumerator:
    | enumeration_constant ['=' constant_expression]

atomic_type_specifier:
    | '_Atomic' '(' type_name ')'

type_qualifier:
    | 'const' | 'restrict' | 'volatile' | '_Atomic'

function_specifier:
    | 'inline' | '_Noreturn'

alignment_specifier:
    | '_Alignas' '(' (type_name | constant_expression) ')'

declarator:
    | [pointer] direct_declarator

direct_declarator:
    | identifier
    | '(' declarator ')'
    | direct_declarator '[' type_qualifier* [assignment_expression] ']'
    | direct_declarator '[' 'static' type_qualifier* assignment_expression ']'
    | direct_declarator '[' type_qualifier+ 'static' assignment_expression ']'
    | direct_declarator '[' type_qualifier+ '*' ']'
    | direct_declarator '(' parameter_type_list ')'
    | direct_declarator '(' [','.identifier+] ')'

pointer:
    | '*' type_qualifier* [pointer]

parameter_type_list:
    | ','.parameter_declaration+ [',' '...']

parameter_declaration:
    | declaration_specifier+ declarator
    | declaration_specifier+ [abstract_declarator]

type_name:
    | specifier_qualifier+ [abstract_declarator]

abstract_declarator:
    | [pointer] direct_abstract_declarator
    | pointer

direct_abstract_declarator:
    | '(' abstract_declarator ')'
    | [direct_abstract_declarator] '[' type_qualifier* [assignment_expression] ']'
    | [direct_abstract_declarator] '[' 'static' type_qualifier* assignment_expression ']'
    | [direct_abstract_declarator] '[' type_qualifier+ 'static' assignment_expression ']'
    | [direct_abstract_declarator] '[' '*' ']'
    | [direct_abstract_declarator] '(' [parameter_type_list] ')'

typedef_name:
    | identifier

initializer:
    | assignment_expression
    | '{' initializer_list [','] '}'

initializer_list:
    | [initializer_list] [designator+ '='] initializer

designator:
    | '[' constant_expression ']'
    | '.' identifier

static_assert_declaration:
    | '_Static_assert' '(' constant_expression ',' string_literal ')' ';'


# A.2.1 Expressions

primary_expression:
    | identifier
    | constant
    | string_literal
    | '(' expression ')'
    | generic_selection

generic_selection:
    | '_Generic' '(' assignment_expression ',' ','.generic_association+ ')'

generic_association:
    | (type_name | 'default') ':' assignment_expression

postfix_expression:
    | primary_expression
    | postfix_expression '[' expression ']'
    | postfix_expression '(' [','.assignment_expression+] ')'
    | postfix_expression '.' identifier
    | postfix_expression '->' identifier
    | postfix_expression '++'
    | postfix_expression '--'
    | '(' type_name ')' '{' initializer_list [','] '}'

unary_expression:
    | postfix_expression
    | '++' unary_expression
    | '--' unary_expression
    | unary_operator cast_expression
    | 'sizeof' unary_expression
    | 'sizeof' '(' type_name ')'
    | '_Alignof' '(' type_name ')'

unary_operator:
    | '&' | '*' | '+' | '-' | '~' | '!'

cast_expression:
    | unary_expression
    | '(' type_name ')' cast_expression

multiplicative_expression:
    | [multiplicative_expression ('*' | '/' | '%')] cast_expression

additive_expression:
    | [additive_expression ('+' | '-')] multiplicative_expression

shift_expression:
    | [shift_expression ('<<' | '>>')] additive_expression

relational_expression:
    | [relational_expression ('<' | '>' | '<=' | '>=')] shift_expression

equality_expression:
    | [equality_expression ('==' | '!=')] relational_expression

and_expression:
    | [and_expression '&'] equality_expression

xor_expression:
    | [xor_expression '^'] and_expression

or_expression:
    | [or_expression '|'] xor_expression

logand_expression:
    | [logand_expression '&&'] or_expression

logor_expression:
    | [logor_expression '||'] logand_expression

conditional_expression:
    | logor_expression ['?' expression ':' conditional_expression]

assignment_expression:
    | conditional_expression
    | unary_expression assignment_operator assignment_expression

assignment_operator:
    | '='
    | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|='

expression:
    | ','.assignment_expression+

constant_expression:
    | conditional_expression
